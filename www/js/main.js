// Generated by CoffeeScript 1.6.3
(function() {
  var Building, CanvasUtils, City, Cloud, Density, HitTest, M_2PI, M_PI, M_PI2, M_PI4, M_PI8, Main, NumberUtils, ObjectPool, Snd, SndFX, TAN_HALF_PI, add, angle, angle_between, average, delta, findCorner, isSquare, isTriangle, len, main, vector,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  City = (function() {
    City.prototype.buildings = null;

    City.prototype.plateform = null;

    City.prototype.max = 402;

    City.prototype.scene = null;

    City.prototype.paris = null;

    City.prototype.hk = null;

    City.prototype.ny = null;

    City.prototype.tokyo = null;

    City.prototype.dubay = null;

    City.prototype.clouds = null;

    function City(scene) {
      var ambient, angle, buildIndex, building, color, count, directionalLight, heigth, i, k, materials, plateform, pointLight, radius, socle, socleGeo, socleMat, step, stepsPower, _i, _ref;
      this.scene = scene;
      this.global3D = new THREE.Object3D();
      ambient = new THREE.AmbientLight(0x303030);
      this.scene.add(ambient);
      directionalLight = new THREE.DirectionalLight(0xffffff);
      directionalLight.position.set(30, 90, 100).normalize();
      this.scene.add(directionalLight);
      pointLight = new THREE.PointLight(0xFF00AA);
      pointLight.position.y = 100;
      this.scene.add(pointLight);
      this.hk = [
        {
          idBtn: "hk",
          density: 6544,
          population: 7071576,
          name: "HongKong"
        }, {
          heigth: 450,
          count: 1,
          color: 0x700000
        }, {
          heigth: 400,
          count: 1,
          color: 0x434B6E
        }, {
          heigth: 350,
          count: 4,
          color: 0x57596B
        }, {
          heigth: 300,
          count: 6,
          color: 0x645666
        }, {
          heigth: 250,
          count: 15,
          color: 0x2B2C36
        }, {
          heigth: 200,
          count: 62,
          color: 0xFF00FF
        }, {
          heigth: 150,
          count: 294,
          color: 0xFFFF00
        }
      ];
      this.ny = [
        {
          idBtn: "ny",
          density: 10630,
          population: 19570261,
          name: "New York"
        }, {
          heigth: 500,
          count: 1,
          color: 0x7381C7
        }, {
          heigth: 450,
          count: 1,
          color: 0x797E99
        }, {
          heigth: 400,
          count: 1,
          color: 0x67739E
        }, {
          heigth: 350,
          count: 2,
          color: 0x67739E
        }, {
          heigth: 300,
          count: 6,
          color: 0x3F446B
        }, {
          heigth: 250,
          count: 13,
          color: 0x67739E
        }, {
          heigth: 200,
          count: 59,
          color: 0x2B3269
        }, {
          heigth: 150,
          count: 227,
          color: 0x4A58C2
        }
      ];
      this.paris = [
        {
          idBtn: "paris",
          density: 21000,
          population: 12161542,
          name: "Paris"
        }, {
          heigth: 300,
          count: 1,
          color: 0x67739E
        }, {
          heigth: 250,
          count: 1,
          color: 0x67739E
        }, {
          heigth: 200,
          count: 3,
          color: 0xCFC5A9
        }, {
          heigth: 150,
          count: 19,
          color: 0x94968A
        }
      ];
      this.tokyo = [
        {
          idBtn: "tokyo",
          density: 6000,
          population: 35000000,
          name: "Tokyo"
        }, {
          heigth: 250,
          count: 1,
          color: 0xFFFFFF
        }, {
          heigth: 200,
          count: 27,
          color: 0xFF1010
        }, {
          heigth: 150,
          count: 125,
          color: 0xFF4D4D
        }
      ];
      this.dubay = [
        {
          idBtn: "dubay",
          density: 463,
          population: 2106177,
          name: "Dubai"
        }, {
          heigth: 800,
          count: 1,
          color: 0x67739E
        }, {
          heigth: 700,
          count: 1,
          color: 0x67739E
        }, {
          heigth: 600,
          count: 1,
          color: 0x67739E
        }, {
          heigth: 500,
          count: 1,
          color: 0x67739E
        }, {
          heigth: 450,
          count: 1,
          color: 0x700000
        }, {
          heigth: 400,
          count: 2,
          color: 0x434B6E
        }, {
          heigth: 350,
          count: 8,
          color: 0x57596B
        }, {
          heigth: 300,
          count: 18,
          color: 0x645666
        }, {
          heigth: 250,
          count: 40,
          color: 0x2B2C36
        }, {
          heigth: 200,
          count: 73,
          color: 0xFF00FF
        }, {
          heigth: 150,
          count: 153,
          color: 0xFFFF00
        }
      ];
      this.buildings = [];
      buildIndex = 1;
      count = 0;
      radius = 0;
      angle = 0;
      step = M_2PI / 1;
      stepsPower = 1;
      k = 0;
      for (i = _i = 0, _ref = this.max; _i <= _ref; i = _i += 1) {
        if (this.hk.length > buildIndex) {
          heigth = this.hk[buildIndex].heigth;
          color = this.hk[buildIndex].color;
        } else {
          color = 0xFFFFFF;
          heigth = 1;
        }
        angle = step * k;
        building = new Building(heigth, color);
        building.updatePosition(radius, angle);
        this.buildings.push(building);
        this.global3D.add(building);
        k++;
        if (k >= stepsPower) {
          stepsPower += 5;
          step = M_2PI / stepsPower;
          k = 0;
          radius += 15;
        }
        count++;
        if (this.hk.length > buildIndex && count >= this.hk[buildIndex].count) {
          count = 0;
          buildIndex++;
        }
      }
      radius += 5;
      socleGeo = new THREE.CylinderGeometry(radius, radius, 4, 40);
      socleMat = new THREE.MeshBasicMaterial({
        color: 0,
        wireframeLinewidth: 1,
        vertexColors: THREE.VertexColors
      });
      plateform = new THREE.Object3D();
      materials = [
        new THREE.MeshBasicMaterial({
          color: 0,
          opacity: .5,
          transparent: true
        }), new THREE.MeshBasicMaterial({
          color: 0x222222,
          opacity: 0.1,
          wireframe: true,
          transparent: true
        })
      ];
      socle = THREE.SceneUtils.createMultiMaterialObject(socleGeo, materials);
      socle.position.y = -2;
      this.global3D.add(socle);
      socleGeo = new THREE.CylinderGeometry(radius / 1.5, 0, 50, 30, 5);
      socleMat = new THREE.MeshBasicMaterial({
        color: 0,
        wireframeLinewidth: 1,
        vertexColors: THREE.VertexColors
      });
      plateform = new THREE.Object3D();
      materials = [
        new THREE.MeshBasicMaterial({
          color: 0,
          opacity: .5,
          transparent: true
        }), new THREE.MeshBasicMaterial({
          color: 0x222222,
          opacity: 0.1,
          wireframe: true,
          transparent: true
        })
      ];
      socle = THREE.SceneUtils.createMultiMaterialObject(socleGeo, materials);
      socle.position.y = -30;
      this.density = new Density(this.global3D);
      this.global3D.add(socle);
      this.scene.add(this.global3D);
      return;
    }

    City.prototype.update = function() {};

    City.prototype.updateHeight = function(city) {
      var buildIndex, building, color, count, density, heigth, i, population, _i, _ref;
      density = city[0].density;
      population = city[0].population;
      this.density.remove();
      this.density = new Density(this.global3D, Math.floor(population / 50000), density);
      buildIndex = 1;
      count = 0;
      for (i = _i = 0, _ref = this.max; _i <= _ref; i = _i += 1) {
        if (city.length > buildIndex) {
          heigth = city[buildIndex].heigth;
          color = city[buildIndex].color;
        } else {
          color = 0xFFFFFF;
          heigth = 1;
        }
        building = this.buildings[i];
        building.update(heigth, color);
        count++;
        if (city.length > buildIndex && count >= city[buildIndex].count) {
          count = 0;
          buildIndex++;
        }
      }
      TweenLite.to(this.global3D.rotation, 1.2, {
        y: this.global3D.rotation.y + Math.PI,
        ease: Quad.easeOut
      });
    };

    return City;

  })();

  Main = (function() {
    Main.prototype.scene = null;

    Main.prototype.renderer = null;

    Main.prototype.camera = null;

    Main.prototype.city = null;

    Main.prototype.dt = 0;

    Main.prototype.lastTime = 0;

    Main.prototype.changeTick = 0;

    Main.prototype.changeTickDuration = 600;

    Main.prototype.citys = null;

    Main.prototype.currentCity = 0;

    Main.prototype.switchAuto = false;

    function Main() {
      this.resize = __bind(this.resize, this);
      this.animate = __bind(this.animate, this);
      var h, w,
        _this = this;
      this.lastTime = Date.now();
      w = window.innerWidth;
      h = window.innerHeight;
      this.camera = new THREE.PerspectiveCamera(70, w / h, 0.1, 10000);
      this.camera.position = new THREE.Vector3(0, 300, 700);
      this.controls = new THREE.TrackballControls(this.camera);
      this.controls.rotateSpeed = 1.0;
      this.controls.zoomSpeed = 1.2;
      this.controls.panSpeed = 0.8;
      this.controls.noZoom = false;
      this.controls.noPan = false;
      this.controls.staticMoving = true;
      this.controls.dynamicDampingFactor = 0.3;
      this.controls.keys = [65, 83, 68];
      this.scene = new THREE.Scene();
      this.scene.add(this.camera);
      this.renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      this.renderer.setSize(w, h);
      $("#container").append(this.renderer.domElement);
      this.city = new City(this.scene);
      this.citys = [this.city.ny, this.city.paris, this.city.hk, this.city.tokyo, this.city.dubay];
      $("#paris").click(function() {
        _this.city.updateHeight(_this.city.paris);
        return _this.select(_this.city.paris);
      });
      $("#hk").click(function() {
        _this.city.updateHeight(_this.city.hk);
        return _this.select(_this.city.hk);
      });
      $("#ny").click(function() {
        _this.city.updateHeight(_this.city.ny);
        return _this.select(_this.city.ny);
      });
      $("#tokyo").click(function() {
        _this.city.updateHeight(_this.city.tokyo);
        return _this.select(_this.city.tokyo);
      });
      $("#dubay").click(function() {
        _this.city.updateHeight(_this.city.dubay);
        return _this.select(_this.city.dubay);
      });
      $("#camera1").click(function() {
        TweenLite.to(_this.camera.position, 1.6, {
          x: 0,
          y: 300,
          z: 700,
          ease: Strong.easeOut
        });
        return TweenLite.to(_this.city.global3D.rotation, 1.3, {
          y: _this.city.global3D.rotation.y + Math.PI,
          ease: Sine.easeOut
        });
      });
      $("#camera2").click(function() {
        TweenLite.to(_this.camera.position, 1.6, {
          x: 0,
          y: 600,
          z: 0.5,
          ease: Strong.easeOut
        });
        return TweenLite.to(_this.city.global3D.rotation, 1.3, {
          y: _this.city.global3D.rotation.y + Math.PI,
          ease: Sine.easeOut
        });
      });
      $("#camera3").click(function() {
        TweenLite.to(_this.camera.position, 1.6, {
          x: 0,
          y: 200,
          z: 400,
          ease: Strong.easeOut
        });
        return TweenLite.to(_this.city.global3D.rotation, 1.3, {
          y: _this.city.global3D.rotation.y + Math.PI,
          ease: Sine.easeOut
        });
      });
      $("#switchAuto").click(function() {
        _this.switchAuto = !_this.switchAuto;
        if (_this.switchAuto) {
          $("#switchAuto a").html("on");
          return _this.changeTick = _this.changeTickDuration;
        } else {
          return $("#switchAuto a").html("off");
        }
      });
      window.addEventListener("resize", this.resize, false);
      requestAnimFrame(this.animate);
      return;
    }

    Main.prototype.animate = function() {
      var dt, t;
      this.city.update();
      t = Date.now();
      dt = t - this.lastTime;
      if (this.switchAuto) {
        this.changeTick += dt;
        if (this.changeTick >= this.changeTickDuration) {
          this.changeTick = 0;
          this.nextCity();
        }
      }
      this.lastTime = t;
      this.camera.lookAt(this.scene.position);
      this.renderer.render(this.scene, this.camera);
      requestAnimFrame(this.animate);
    };

    Main.prototype.resize = function() {
      this.camera.aspect = window.innerWidth / window.innerHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(window.innerWidth, window.innerHeight);
    };

    Main.prototype.nextCity = function() {
      this.currentCity++;
      this.currentCity %= this.citys.length;
      this.city.updateHeight(this.citys[this.currentCity]);
      this.select(this.citys[this.currentCity]);
    };

    Main.prototype.select = function(city) {
      $("div.city a").removeClass("selected");
      $("div#" + city[0].idBtn + " a").addClass("selected");
    };

    return Main;

  })();

  main = null;

  $(document).ready(function() {
    main = new Main();
  });

  Building = (function(_super) {
    __extends(Building, _super);

    Building.prototype.angle = 0;

    Building.prototype.radius = 0;

    Building.prototype.r = 0;

    Building.prototype.g = 0;

    Building.prototype.b = 0;

    function Building(h, color) {
      var materials, opacity;
      this.color = color;
      this.needUpdateRequest = __bind(this.needUpdateRequest, this);
      opacity = .1;
      this.color = 0xFFFFFF;
      this.geometry = new THREE.CubeGeometry(5, 1, 5);
      this.material = new THREE.MeshLambertMaterial({
        color: this.color,
        opacity: opacity,
        transparent: true
      });
      materials = [
        this.material, new THREE.MeshBasicMaterial({
          color: 0x222222,
          opacity: 0.1,
          wireframe: false,
          transparent: false
        })
      ];
      THREE.SceneUtils.createMultiMaterialObject.call(this, this.geometry, this.material);
      THREE.Mesh.call(this, this.geometry, this.material);
      this.position.y = 1 / 2;
      return;
    }

    Building.prototype.updatePosition = function(radius, angle) {
      if (radius) {
        this.radius = radius;
      }
      if (angle) {
        this.angle = angle;
      }
      this.position.x = Math.cos(this.angle) * this.radius;
      this.position.z = Math.sin(this.angle) * this.radius;
    };

    Building.prototype.update = function(height, color) {
      this.color = color;
      height /= 4;
      TweenLite.to(this, .5, {
        r: (this.color >> 16 & 255) / 255,
        g: (this.color >> 8 & 255) / 255,
        b: (this.color & 255) / 255
      });
      TweenLite.to(this.geometry.vertices[0], 1, {
        y: height,
        onUpdate: this.needUpdateRequest
      });
      TweenLite.to(this.geometry.vertices[1], 1, {
        y: height
      });
      TweenLite.to(this.geometry.vertices[4], 1, {
        y: height
      });
      TweenLite.to(this.geometry.vertices[5], 1, {
        y: height
      });
    };

    Building.prototype.needUpdateRequest = function() {
      this.material.color.setRGB(this.r, this.g, this.b);
      this.material.opacity = Math.min(Math.max(this.geometry.vertices[0].y / 130, .1), .8);
      this.geometry.verticesNeedUpdate = true;
      this.geometry.elementsNeedUpdate = true;
      this.geometry.morphTargetsNeedUpdate = true;
      this.geometry.uvsNeedUpdate = true;
      this.geometry.normalsNeedUpdate = true;
      this.geometry.colorsNeedUpdate = true;
      this.geometry.tangentsNeedUpdate = true;
    };

    return Building;

  })(THREE.Mesh);

  Cloud = (function(_super) {
    __extends(Cloud, _super);

    Cloud.prototype.angle = 0;

    Cloud.prototype.radius = 0;

    Cloud.prototype.r = 0;

    Cloud.prototype.g = 0;

    Cloud.prototype.b = 0;

    function Cloud() {
      this.geometry = new THREE.CubeGeometry(10 + Math.random() * 20, 10, 10 + Math.random() * 20);
      this.material = new THREE.MeshBasicMaterial({
        color: 0xFFFFFF,
        opacity: .9,
        transparent: true
      });
      THREE.Mesh.call(this, this.geometry, this.material);
      this.position.y = 100 + Math.random() * 100;
      this.position.x = Math.random() * 300 - 150;
      this.position.z = Math.random() * 300 - 150;
      return;
    }

    return Cloud;

  })(THREE.Mesh);

  /*
  # Usage :
  # SndFX.load(urls,onComplete)
  # SndFX.addFilter(id, filter)
  # SndFX.getFilter(id)
  #
  # snd.onComplete = onSndEnd
  # snd = new Snd(id)
  # snd.play()
  # snd.stop()
  # snd.connectTo(filter)
  # 
  # source => panner => gain => filters => masterGain
  */


  Snd = (function() {
    Snd.prototype.id = null;

    Snd.prototype.source = null;

    Snd.prototype.gain = null;

    Snd.prototype.destination = null;

    Snd.prototype.panner = null;

    Snd.prototype.domAudio = null;

    Snd.prototype._volume = 0;

    Snd.prototype.onComplete = null;

    function Snd(id, options) {
      if (options == null) {
        options = {};
      }
      this.id = id = SndFX.instance.replaceSuffix(id);
      options.autoplay = options.autoplay || false;
      if (SndFX.instance.webAudio) {
        if (options.volume === void 0) {
          options.volume = 1.0;
        }
      } else {
        if (options.volume === void 0) {
          options.volume = SndFX.instance.volume;
        }
      }
      console.log(options.volume);
      options.destination = options.destination || SndFX.instance.masterGain;
      if (SndFX.instance.webAudio) {
        this.source = SndFX.instance.context.createBufferSource();
        this.source.buffer = SndFX.instance.buffers[id];
        this.gainNode = SndFX.instance.createGain();
        this.gainNode.connect(options.destination);
        this.panner = SndFX.instance.createPanner();
        this.panner.setPosition(0, 0, 0);
        this.panner.connect(this.gainNode);
        this.source.connect(this.panner);
        if (options.autoplay) {
          this.play(0);
        }
      } else {
        this.domAudio = new Audio();
        this.domAudio.autoplay = options.autoplay;
        this.domAudio.src = id;
        this.domAudio.load();
      }
      this.volume(options.volume);
      return this;
    }

    Snd.prototype.play = function(_when, _loop) {
      if (_when == null) {
        _when = 0;
      }
      if (_loop == null) {
        _loop = false;
      }
      if (SndFX.instance.webAudio) {
        this.source.loop = _loop;
        if (!this.source.start) {
          this.source.noteOn(_when);
        } else {
          this.source.start(_when);
        }
      } else {
        this.domAudio.loop = _loop;
        this.domAudio.play();
      }
      return this;
    };

    Snd.prototype.stop = function(delay) {
      if (delay == null) {
        delay = 0;
      }
      if (SndFX.instance.webAudio) {
        if (!this.source.stop) {
          this.source.noteOff(delay);
        } else {
          this.source.stop(delay);
        }
      } else {
        this.domAudio.pause();
      }
      return this;
    };

    Snd.prototype.setPosition = function(x, y, z) {
      if (y == null) {
        y = 0;
      }
      if (z == null) {
        z = 0;
      }
      this.panner.setPosition(x, y, z);
    };

    Snd.prototype.volume = function(vol) {
      var _volume;
      if (vol == null) {
        vol = null;
      }
      if (vol >= 0 && vol <= 1) {
        vol = parseFloat(vol);
        if (SndFX.instance.webAudio) {
          this.gainNode.gain.value = vol;
        } else {
          this.domAudio.volume = vol;
        }
        return _volume = vol;
      } else {
        return _volume;
      }
    };

    Snd.prototype.connectTo = function(destination, autoConnectDestination) {
      if (autoConnectDestination == null) {
        autoConnectDestination = false;
      }
      if (!SndFX.instance.webAudio) {
        return;
      }
      this.gainNode.disconnect(0);
      this.gainNode.connect(destination);
      if (autoConnectDestination) {
        destination.connect(SndFX.instance.masterGain);
      }
      return this;
    };

    Snd.prototype.update = function(dt) {};

    Snd.prototype.dispose = function() {
      var id;
      if (SndFX.instance.webAudio) {
        this.panner.disconnect(0);
        this.gainNode.disconnect(0);
        this.source.disconnect(0);
        this.source.stop(0);
        this.panner = null;
        this.gainNode = null;
        this.source.buffer = null;
        this.source = null;
      } else {
        this.domAudio.pause();
        this.domAudio = null;
      }
      SndFX.remove(this);
      id = null;
    };

    return Snd;

  })();

  SndFX = (function() {
    SndFX.prototype.cache = {};

    SndFX.prototype.context = null;

    SndFX.prototype.masterGain = null;

    SndFX.prototype._volume = 1;

    SndFX.prototype.buffers = null;

    SndFX.prototype.snds = null;

    SndFX.prototype.codecs = null;

    SndFX.prototype.onload = null;

    SndFX.prototype.urls = null;

    SndFX.prototype.loadCount = 0;

    SndFX.prototype.webAudio = false;

    function SndFX() {
      var audioTest;
      console.log("SndFX");
      if (SndFX.instance) {
        throw new Error("You can't create an instance of SndFX");
      }
      if (window.AudioContext) {
        this.webAudio = true;
        this.context = new AudioContext();
      } else if (window.webkitAudioContext) {
        this.webAudio = true;
        this.context = new webkitAudioContext();
      } else {
        this.webAudio = false;
      }
      if (this.webAudio) {
        this.masterGain = this.createGain();
        this.masterGain.gain.value = 1;
        this.masterGain.connect(this.context.destination);
      }
      audioTest = new Audio();
      this.codecs = {
        mp3: !!audioTest.canPlayType('audio/mpeg;').replace(/^no$/, ''),
        opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ''),
        ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
        wav: !!audioTest.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ''),
        m4a: !!(audioTest.canPlayType('audio/x-m4a;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
        webm: !!audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, '')
      };
      this.cache = {};
      this.buffers = {};
      this.snds = [];
      return;
    }

    SndFX.prototype.volume = function(vol) {
      var snd, _i, _len, _ref;
      vol = parseFloat(vol);
      if (vol && vol >= 0 && vol <= 1) {
        this._volume = vol;
        if (this.webAudio) {
          this.masterGain.gain.value = vol;
        } else {
          _ref = this.sounds;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            snd = _ref[_i];
            snd.volume(vol);
          }
        }
      }
      if (this.webAudio) {
        return this.masterGain.gain.value;
      } else {
        return this._volume;
      }
    };

    SndFX.prototype.load = function(urls, callback) {
      var i, loader, _i, _j, _k, _ref, _ref1, _ref2;
      this.urls = urls;
      if (callback == null) {
        callback = null;
      }
      for (i = _i = 0, _ref = urls.length; _i < _ref; i = _i += 1) {
        urls[i] = this.replaceSuffix(urls[i]);
      }
      this.onload = callback;
      this.loadCount = 0;
      loader = this;
      if (this.webAudio) {
        for (i = _j = 0, _ref1 = urls.length; _j < _ref1; i = _j += 1) {
          this.loadBuffer(urls[i], i);
        }
      } else {
        for (i = _k = 0, _ref2 = urls.length; _k < _ref2; i = _k += 1) {
          this.loadAudio(urls[i]);
        }
      }
    };

    SndFX.prototype.replaceSuffix = function(url) {
      var suffix;
      if (this.codecs.mp3) {
        return url;
      }
      suffix = "";
      if (this.codecs.ogg) {
        suffix = "ogg";
      } else if (this.codecs.wav) {
        suffix = "wav";
      } else {
        return url;
      }
      url = url.replace("mp3", suffix);
      return url;
    };

    SndFX.prototype.loadBuffer = function(url, index) {
      var loader, request;
      console.log(url);
      request = new XMLHttpRequest();
      request.open("GET", url, true);
      request.responseType = "arraybuffer";
      loader = this;
      request.onload = function() {
        var _this = this;
        return loader.context.decodeAudioData(request.response, function(buffer) {
          if (!buffer) {
            alert('error decoding file data: ' + url);
            return;
          }
          loader.buffers[loader.replaceSuffix(url)] = buffer;
          if (++loader.loadCount === loader.urls.length && loader.onload !== null) {
            return loader.onload();
          }
        }, function(error) {
          return console.error('decodeAudioData error', error);
        });
      };
      request.onerror = function() {
        return alert('BufferLoader: XHR error');
      };
      request.send();
    };

    SndFX.prototype.loadAudio = function(url) {
      var loader, sound;
      loader = this;
      sound = new Audio();
      this.cache[url] = sound;
      sound.addEventListener("canplaythrough", function() {
        if (++loader.loadCount === loader.urls.length && loader.onload !== null) {
          return loader.onload();
        }
      }, false);
      sound.src = url;
      sound.load();
    };

    SndFX.prototype.getByID = function(id) {
      var snd, _i, _len, _ref;
      _ref = this.sounds;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        snd = _ref[_i];
        if (snd.id === id) {
          return snd;
        }
      }
      return null;
    };

    SndFX.prototype.createGain = function() {
      if (this.context.createGain) {
        return this.context.createGain();
      } else {
        return this.context.createGainNode();
      }
    };

    SndFX.prototype.createPanner = function() {
      if (this.context.createPanner) {
        return this.context.createPanner();
      } else {
        return this.context.createPannerNode();
      }
    };

    SndFX.prototype.remove = function(snd) {
      var idx;
      idx = this.sounds.indexOf(snd);
      if (idx === -1) {
        return;
      }
      return this.sounds.splice(idx, 1);
    };

    SndFX.prototype.update = function(dt) {
      var snd, _i, _len, _ref, _results;
      _ref = this.sounds;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        snd = _ref[_i];
        _results.push(snd.update(dt));
      }
      return _results;
    };

    SndFX.instance = new SndFX();

    return SndFX;

  })();

  CanvasUtils = (function() {
    function CanvasUtils() {}

    CanvasUtils.fromImage = function(image) {
      var canvas, context;
      canvas = document.createElement('canvas');
      canvas.width = image.width;
      canvas.height = image.height;
      context = canvas.getContext('2d');
      context.width = image.width;
      context.height = image.height;
      context.drawImage(image, 0, 0);
      console.log(canvas);
      return canvas;
    };

    CanvasUtils.dataFromImage = function(image) {
      return CanvasUtils.fromImage(image).getContext('2d').getImageData(0, 0, image.width, image.height);
    };

    return CanvasUtils;

  })();

  M_PI = Math.PI;

  M_2PI = Math.PI * 2;

  M_PI2 = Math.PI / 2;

  M_PI4 = Math.PI / 4;

  M_PI8 = Math.PI / 8;

  HitTest = (function() {
    function HitTest() {
      return;
    }

    HitTest.testCircle = function(position, object, radius) {
      var dist, dx, dy;
      if (radius == null) {
        radius = object.radius;
      }
      dx = object.position.x - position.x;
      dy = object.position.y - position.y;
      dist = Math.sqrt(dx * dx + dy * dy);
      return dist <= radius;
    };

    HitTest.testElipse = function(position, object, width, height) {
      var dx, dy;
      dx = object.position.x - position.x;
      dy = object.position.y - position.y;
      return ((dx * dx) / (width * width)) + ((dy * dy) / (height * height)) <= 1.0;
    };

    HitTest.testRect = function(position, object) {
      return position.x >= object.position.x && position.y >= object.position.y && position.x <= object.position.x + object.width && position.y <= object.position.y + object.height;
    };

    HitTest.testRect = function(position, object, centred) {
      position.x += object.width / 2;
      position.y += object.height / 2;
      return HitTest.testRect(position, object);
    };

    return HitTest;

  })();

  TAN_HALF_PI = Math.tan(Math.PI / 2);

  vector = function(x, y) {
    return {
      x: x,
      y: y
    };
  };

  delta = function(a, b) {
    return vector(a.x - b.x, a.y - b.y);
  };

  angle = function(d) {
    return Math.atan((1.0 * d.y) / d.x);
  };

  angle_between = function(a, b) {
    return Math.acos((a.x * b.x + a.y * b.y) / (len(a) * len(b)));
  };

  len = function(v) {
    return Math.sqrt(v.x * v.x + v.y * v.y);
  };

  add = function(a, b) {
    return vector(a.x + b.x, a.y + b.y);
  };

  average = function(l) {
    var i, x, y;
    x = 0;
    y = 0;
    i = 0;
    while (i < l.length) {
      x += l[i].x;
      y += l[i].y;
      i++;
    }
    return vector(x / l.length, y / l.length);
  };

  findCorner = function(line) {
    var ac, c, c2, corners, d, i, lastCorner, pt, _i, _j, _ref, _ref1;
    corners = [line[0]];
    lastCorner = line[0];
    for (i = _i = 1, _ref = line.length - 1; _i < _ref; i = _i += 1) {
      pt = line[i];
      d = delta(lastCorner, pt);
      if (Math.abs(len(d)) > 10) {
        ac = delta(pt, line[i + 1]);
        if (Math.abs(angle_between(ac, d)) > Math.PI / 4) {
          pt.index = i;
          corners.push(pt);
          lastCorner = pt;
        }
      }
    }
    corners.push(line[line.length - 1]);
    for (i = _j = 1, _ref1 = corners.length; _j <= _ref1; i = _j += 1) {
      c = corners[i % corners.length];
      c2 = corners[i - 1];
      if ((Math.abs(c.x - c2.x) + Math.abs(c.y - c2.y)) < 30) {
        corners.splice(i - 1, 1);
        break;
      }
    }
    return corners;
  };

  isTriangle = function(corners) {
    var c0, c1, c2;
    if (corners.length !== 3) {
      return false;
    }
    corners.sort(function(a, b) {
      return a.x < b.x;
    });
    c0 = corners[0];
    c1 = corners[1];
    c2 = corners[2];
    if (c0.y > c1.y && c2.y > c1.y) {
      return true;
    }
    return false;
  };

  isSquare = function(corners) {
    var c0, c1, c2, c3, tolerance;
    if (corners.length !== 4) {
      return false;
    }
    corners.sort(function(a, b) {
      return a.x < b.x;
    });
    if (corners[0].y < corners[1].y) {
      c0 = corners[0];
      corners[0] = corners[1];
      corners[1] = c0;
    }
    if (corners[2].y < corners[3].y) {
      c2 = corners[2];
      corners[2] = corners[3];
      corners[3] = c2;
    }
    c0 = corners[0];
    c1 = corners[1];
    c2 = corners[2];
    c3 = corners[3];
    tolerance = 25;
    if (Math.abs(c0.x - c1.x) < tolerance && Math.abs(c2.x - c3.x) < tolerance) {
      return true;
    }
    return false;
  };

  NumberUtils = (function() {
    function NumberUtils() {
      throw new Error("you can t create an instance of NumberUtils");
    }

    NumberUtils.addZero = function(string, minLenght) {
      string += "";
      while (string.length < minLenght) {
        string = "0" + string;
      }
      return string;
    };

    return NumberUtils;

  })();

  ObjectPool = (function() {
    function ObjectPool(create, minSize, maxSize) {
      var _i, _ref;
      this.create = create;
      this.minSize = minSize;
      this.maxSize = maxSize;
      this.list = [];
      for (_i = 0, _ref = this.minSize; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--) {
        this.add();
      }
      return;
    }

    ObjectPool.prototype.add = function() {
      return this.list.push(this.create());
    };

    ObjectPool.prototype.checkOut = function() {
      var i;
      if (this.list.length === 0) {
        return i = this.create();
      } else {
        return i = this.list.pop();
      }
    };

    ObjectPool.prototype.checkIn = function(item) {
      if (this.list.length < this.maxSize) {
        return this.list.push(item);
      }
    };

    return ObjectPool;

  })();

  Density = (function() {
    function Density(container, count, space, radius, height) {
      var geometry, i, randomRadius, vertex, _i, _ref;
      this.container = container;
      this.count = count != null ? count : 100;
      this.space = space != null ? space : 6000;
      this.radius = radius != null ? radius : 200;
      this.height = height != null ? height : 20;
      this.dispose = __bind(this.dispose, this);
      geometry = new THREE.Geometry();
      randomRadius = 20;
      M_PI2 = Math.PI * 2;
      angle = 0;
      console.log(1 / this.space);
      this.radius *= 1 / this.space * 500;
      this.radius += 200;
      for (i = _i = 0, _ref = this.count; _i < _ref; i = _i += 1) {
        vertex = new THREE.Vector3();
        angle += this.space;
        vertex.x = Math.cos(angle) * (this.radius + randomRadius * i / 100);
        vertex.z = Math.sin(angle) * (this.radius + randomRadius * i / 100);
        vertex.y = this.height * (this.count - i) / 300 - 20;
        geometry.vertices[i] = vertex;
      }
      this.material = new THREE.ParticleBasicMaterial({
        opacity: 0,
        size: 1,
        sizeAttenuation: false,
        transparent: true
      });
      this.material.color.setHSL(.5, 0, 1);
      TweenLite.to(this.material, .6, {
        opacity: 1
      });
      this.particles = new THREE.ParticleSystem(geometry, this.material);
      this.particles.sortParticles = true;
      this.container.add(this.particles);
      return;
    }

    Density.prototype.remove = function() {
      TweenLite.to(this.material, .6, {
        opacity: 0,
        onComplete: this.dispose
      });
    };

    Density.prototype.dispose = function() {
      this.container.remove(this.particles);
    };

    return Density;

  })();

}).call(this);
