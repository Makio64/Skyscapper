// Generated by CoffeeScript 1.6.3
(function() {
  var AScene, BackgroundController, Bezier, Building, CameraController, CanvasUtils, City, Cloud, CubicBezier, GameScene, HitTest, LoadScene, M_2PI, M_PI, M_PI2, M_PI4, M_PI8, Main, NumberUtils, ObjectPool, Point, SceneTraveler, Snd, SndFX, StartScene, TAN_HALF_PI, add, angle, angle_between, average, delta, findCorner, isSquare, isTriangle, len, main, vector,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  CameraController = (function() {
    CameraController.prototype.camera = null;

    CameraController.prototype.rotation = 0;

    CameraController.prototype.y = 0;

    CameraController.prototype.radius = 320;

    CameraController.prototype.radiusOffset = 0;

    CameraController.prototype.maxY = 200;

    CameraController.prototype.minY = -200;

    CameraController.prototype.radiusfriction = 0.95;

    function CameraController(camera) {
      this.camera = camera;
      return;
    }

    CameraController.prototype.update = function(vx, vy) {
      var x, y, z;
      this.rotation += vx;
      this.y += vy;
      this.y = Math.max(Math.min(this.y, this.maxY), this.minY);
      if (this.y < this.maxY - 120) {
        this.radiusOffset += (Math.abs(vy * 10) - this.radiusOffset) * .5;
      } else {
        this.radiusOffset *= .95;
      }
      x = Math.cos(this.rotation) * (this.radius + this.radiusOffset);
      y = this.y;
      z = Math.sin(this.rotation) * (this.radius + this.radiusOffset);
      this.camera.position.set(x, y, z);
      this.camera.lookAt(new THREE.Vector3(0, this.y + vy * 10, 0));
    };

    return CameraController;

  })();

  City = (function() {
    City.prototype.buildings = null;

    City.prototype.plateform = null;

    City.prototype.max = 402;

    City.prototype.scene = null;

    City.prototype.paris = null;

    City.prototype.hk = null;

    City.prototype.ny = null;

    City.prototype.tokyo = null;

    City.prototype.dubay = null;

    City.prototype.clouds = null;

    function City(scene) {
      var ambient, angle, buildIndex, building, color, count, directionalLight, heigth, i, k, materials, plateform, pointLight, radius, socle, socleGeo, socleMat, step, stepsPower, _i, _ref;
      this.scene = scene;
      this.global3D = new THREE.Object3D();
      this.global3D.add();
      ambient = new THREE.AmbientLight(0x303030);
      this.scene.add(ambient);
      directionalLight = new THREE.DirectionalLight(0xffffff);
      directionalLight.position.set(30, 90, 100).normalize();
      this.scene.add(directionalLight);
      pointLight = new THREE.PointLight(0xFF00AA);
      pointLight.position.y = 100;
      this.scene.add(pointLight);
      this.hk = [
        {
          heigth: 450,
          count: 1,
          color: 0x700000
        }, {
          heigth: 400,
          count: 1,
          color: 0x434B6E
        }, {
          heigth: 350,
          count: 4,
          color: 0x57596B
        }, {
          heigth: 300,
          count: 6,
          color: 0x645666
        }, {
          heigth: 250,
          count: 15,
          color: 0x2B2C36
        }, {
          heigth: 200,
          count: 62,
          color: 0xFF00FF
        }, {
          heigth: 150,
          count: 294,
          color: 0xFFFF00
        }
      ];
      this.ny = [
        {
          heigth: 500,
          count: 1,
          color: 0x7381C7
        }, {
          heigth: 450,
          count: 1,
          color: 0x797E99
        }, {
          heigth: 400,
          count: 1,
          color: 0x67739E
        }, {
          heigth: 350,
          count: 2,
          color: 0x67739E
        }, {
          heigth: 300,
          count: 6,
          color: 0x3F446B
        }, {
          heigth: 250,
          count: 13,
          color: 0x67739E
        }, {
          heigth: 200,
          count: 59,
          color: 0x2B3269
        }, {
          heigth: 150,
          count: 227,
          color: 0x4A58C2
        }
      ];
      this.paris = [
        {
          heigth: 300,
          count: 1,
          color: 0x67739E
        }, {
          heigth: 250,
          count: 1,
          color: 0x67739E
        }, {
          heigth: 200,
          count: 3,
          color: 0xCFC5A9
        }, {
          heigth: 150,
          count: 19,
          color: 0x94968A
        }
      ];
      this.tokyo = [
        {
          heigth: 250,
          count: 1,
          color: 0x67739E
        }, {
          heigth: 200,
          count: 27,
          color: 0xFF1010
        }, {
          heigth: 150,
          count: 125,
          color: 0xFF4D4D
        }
      ];
      this.dubay = [
        {
          heigth: 800,
          count: 1,
          color: 0x67739E
        }, {
          heigth: 700,
          count: 1,
          color: 0x67739E
        }, {
          heigth: 600,
          count: 1,
          color: 0x67739E
        }, {
          heigth: 500,
          count: 1,
          color: 0x67739E
        }, {
          heigth: 450,
          count: 1,
          color: 0x700000
        }, {
          heigth: 400,
          count: 2,
          color: 0x434B6E
        }, {
          heigth: 350,
          count: 8,
          color: 0x57596B
        }, {
          heigth: 300,
          count: 18,
          color: 0x645666
        }, {
          heigth: 250,
          count: 40,
          color: 0x2B2C36
        }, {
          heigth: 200,
          count: 73,
          color: 0xFF00FF
        }, {
          heigth: 150,
          count: 153,
          color: 0xFFFF00
        }
      ];
      this.buildings = [];
      buildIndex = 0;
      count = 0;
      radius = 0;
      angle = 0;
      step = M_2PI / 1;
      stepsPower = 1;
      k = 0;
      for (i = _i = 0, _ref = this.max; _i <= _ref; i = _i += 1) {
        if (this.hk.length > buildIndex) {
          heigth = this.hk[buildIndex].heigth;
          color = this.hk[buildIndex].color;
        } else {
          color = 0xFFFFFF;
          heigth = 1;
        }
        angle = step * k;
        building = new Building(heigth, color);
        building.updatePosition(radius, angle);
        this.buildings.push(building);
        this.scene.add(building);
        k++;
        if (k >= stepsPower) {
          stepsPower += 5;
          step = M_2PI / stepsPower;
          k = 0;
          radius += 15;
        }
        count++;
        if (this.hk.length > buildIndex && count >= this.hk[buildIndex].count) {
          count = 0;
          buildIndex++;
        }
      }
      radius += 5;
      socleGeo = new THREE.CylinderGeometry(radius, radius, 4, 40);
      socleMat = new THREE.MeshBasicMaterial({
        color: 0,
        wireframeLinewidth: 1,
        vertexColors: THREE.VertexColors
      });
      plateform = new THREE.Object3D();
      materials = [
        new THREE.MeshBasicMaterial({
          color: 0,
          opacity: .5,
          transparent: true
        }), new THREE.MeshBasicMaterial({
          color: 0x222222,
          opacity: 0.1,
          wireframe: true,
          transparent: true
        })
      ];
      socle = THREE.SceneUtils.createMultiMaterialObject(socleGeo, materials);
      socle.position.y = -2;
      this.scene.add(socle);
      socleGeo = new THREE.CylinderGeometry(radius / 1.5, 0, 50, 30, 5);
      socleMat = new THREE.MeshBasicMaterial({
        color: 0,
        wireframeLinewidth: 1,
        vertexColors: THREE.VertexColors
      });
      plateform = new THREE.Object3D();
      materials = [
        new THREE.MeshBasicMaterial({
          color: 0,
          opacity: .5,
          transparent: true
        }), new THREE.MeshBasicMaterial({
          color: 0x222222,
          opacity: 0.1,
          wireframe: true,
          transparent: true
        })
      ];
      socle = THREE.SceneUtils.createMultiMaterialObject(socleGeo, materials);
      socle.position.y = -30;
      this.scene.add(socle);
      return;
    }

    City.prototype.update = function() {};

    City.prototype.updateHeight = function(city) {
      var buildIndex, building, color, count, heigth, i, _i, _ref;
      buildIndex = 0;
      count = 0;
      for (i = _i = 0, _ref = this.max; _i <= _ref; i = _i += 1) {
        if (city.length > buildIndex) {
          heigth = city[buildIndex].heigth;
          color = city[buildIndex].color;
        } else {
          color = 0xFFFFFF;
          heigth = 1;
        }
        building = this.buildings[i];
        building.update(heigth, color);
        count++;
        if (city.length > buildIndex && count >= city[buildIndex].count) {
          count = 0;
          buildIndex++;
        }
      }
    };

    return City;

  })();

  Main = (function() {
    Main.prototype.scene = null;

    Main.prototype.renderer = null;

    Main.prototype.camera = null;

    Main.prototype.city = null;

    Main.prototype.dt = 0;

    Main.prototype.lastTime = 0;

    function Main() {
      this.animate = __bind(this.animate, this);
      var h, w,
        _this = this;
      this.lastTime = Date.now();
      w = window.innerWidth;
      h = window.innerHeight;
      this.camera = new THREE.PerspectiveCamera(70, w / h);
      this.camera.position = new THREE.Vector3(190, 190, 190);
      this.controls = new THREE.TrackballControls(this.camera);
      this.controls.rotateSpeed = 1.0;
      this.controls.zoomSpeed = 1.2;
      this.controls.panSpeed = 0.8;
      this.controls.noZoom = false;
      this.controls.noPan = false;
      this.controls.staticMoving = true;
      this.controls.dynamicDampingFactor = 0.3;
      this.controls.keys = [65, 83, 68];
      this.scene = new THREE.Scene();
      this.scene.add(this.camera);
      this.renderer = new THREE.WebGLRenderer();
      this.renderer.setSize(w, h);
      $("#container").append(this.renderer.domElement);
      this.city = new City(this.scene);
      $("#paris").click(function() {
        return _this.city.updateHeight(_this.city.paris);
      });
      $("#hk").click(function() {
        return _this.city.updateHeight(_this.city.hk);
      });
      $("#ny").click(function() {
        return _this.city.updateHeight(_this.city.ny);
      });
      $("#tokyo").click(function() {
        return _this.city.updateHeight(_this.city.tokyo);
      });
      $("#dubay").click(function() {
        return _this.city.updateHeight(_this.city.dubay);
      });
      requestAnimFrame(this.animate);
      return;
    }

    Main.prototype.animate = function() {
      var dt, t;
      this.controls.update();
      t = Date.now();
      dt = t - this.lastTime;
      this.lastTime = t;
      this.camera.lookAt(this.scene.position);
      this.renderer.render(this.scene, this.camera);
      requestAnimFrame(this.animate);
    };

    return Main;

  })();

  main = null;

  $(document).ready(function() {
    main = new Main();
  });

  /*
  # Bezier
  # Quadratic bezier ( curve define by 3 points )
  # @author David Ronai aka Makio64 // makiopolis.com
  */


  Bezier = (function() {
    var _this = this;

    Bezier.prototype.p0 = null;

    Bezier.prototype.p1 = null;

    Bezier.prototype.p2 = null;

    function Bezier(p0, p1, p2) {
      this.p0 = p0;
      this.p1 = p1;
      this.p2 = p2;
    }

    Bezier.prototype.dispose = function() {
      this.p0.dispose();
      this.p1.dispose();
      this.p2.dispose();
      this.p2 = null;
      this.p1 = null;
      return this.p0 = null;
    };

    Bezier.prototype.getBezierPoint = function(t) {
      var x, y;
      if (t == null) {
        t = 0.0;
      }
      x = Math.pow(1 - t, 2) * this.p0.x + 2 * t * (1 - t) * this.p1.x + Math.pow(t, 2) * this.p2.x;
      y = Math.pow(1 - t, 2) * this.p0.y + 2 * t * (1 - t) * this.p1.y + Math.pow(t, 2) * this.p2.y;
      return new Point(x, y);
    };

    Bezier.prototype.toCubic = function() {
      var new1, new2, points;
      points = [];
      new1 = new Point((this.p1.x + this.p0.x) * .5, (this.p1.y + this.p0.y) * .5);
      new2 = new Point((this.p2.x + this.p1.x) * .5, (this.p2.y + this.p1.y) * .5);
      points[0] = new Point(this.p0.x, this.p0.y);
      points[1] = new1;
      points[2] = new2;
      points[3] = new Point(this.p2.x, this.p2.y);
      return points;
    };

    Bezier.toBezier = function(points, division) {
      var b, c, cubic, finalPoints, i, p1, p2, p3, t, _i, _j, _k, _ref, _ref1, _ref2;
      if (division == null) {
        division = 10;
      }
      cubic = [];
      finalPoints = [];
      for (i = _i = 0, _ref = points.length - 1; _i < _ref; i = _i += 1) {
        p1 = points[i];
        p2 = points[(i + 1) % points.length];
        p3 = points[(i + 2) % points.length];
        b = new Bezier(p1, p2, p3);
        c = b.toCubic();
        cubic.push(p1);
        cubic.push(c[1]);
      }
      for (i = _j = 1, _ref1 = cubic.length - 3; _j < _ref1; i = _j += 2) {
        p1 = cubic[i];
        p2 = cubic[i + 1];
        p3 = cubic[i + 2];
        b = new Bezier(p1, p2, p3);
        for (t = _k = 0.0, _ref2 = 1.0 / division; _ref2 > 0 ? _k < 1.0 : _k > 1.0; t = _k += _ref2) {
          finalPoints.push(b.getBezierPoint(t));
        }
      }
      return finalPoints;
    };

    return Bezier;

  }).call(this);

  /*
  # CubicBezier - Bezier
  # Simple class for cubic bezier ( curve define by 4 points )
  # @author David Ronai aka Makio64 // makiopolis.com
  */


  CubicBezier = (function() {
    CubicBezier.prototype.p0 = null;

    CubicBezier.prototype.p1 = null;

    CubicBezier.prototype.p2 = null;

    CubicBezier.prototype.p3 = null;

    function CubicBezier(p0, p1, p2, p3) {
      this.p3 = p3;
      this.p2 = p2;
      this.p1 = p1;
      this.p0 = p0;
    }

    CubicBezier.prototype.dispose = function() {
      this.p0.dispose();
      this.p1.dispose();
      this.p2.dispose();
      this.p3.dispose();
      this.p3 = null;
      this.p2 = null;
      this.p1 = null;
      return this.p0 = null;
    };

    CubicBezier.prototype.getBezierPoint = function(t) {
      if (t == null) {
        t = 0.0;
      }
      return new Point(Math.pow(1 - t, 3) * this.p0.x + 3 * t * Math.pow(1 - t, 2) * this.p1.x + 3 * t * t * (1 - t) * this.p2.x + t * t * t * this.p3.x, Math.pow(1 - t, 3) * this.p0.y + 3 * t * Math.pow(1 - t, 2) * this.p1.y + 3 * t * t * (1 - t) * this.p2.y + t * t * t * this.p3.y);
    };

    return CubicBezier;

  })();

  Point = (function() {
    var euclidean;

    Point.prototype.x = 0.0;

    Point.prototype.y = 0.0;

    function Point(x, y) {
      this.x = x;
      this.y = y;
      return;
    }

    euclidean = function(p1, p2) {
      var a, b;
      a = (p1 != null ? p1.x : void 0) - (p2 != null ? p2.x : void 0);
      b = (p1 != null ? p1.y : void 0) - (p2 != null ? p2.y : void 0);
      return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));
    };

    Point.prototype.add = function(p) {
      this.x += p.x;
      return this.y += p.y;
    };

    Point.prototype.sub = function(p) {
      this.x -= p.x;
      return this.y -= p.y;
    };

    Point.prototype.scale = function(value) {
      this.x *= value;
      return this.y *= value;
    };

    Point.prototype.draw = function(ctx) {
      ctx.fillStyle = '#FFFFFF';
      ctx.fillRect(this.x, this.y, 1, 1);
    };

    Point.prototype.toString = function() {
      return "(" + this.x + ", " + this.y + ")";
    };

    Point.prototype.dispose = function() {};

    return Point;

  })();

  Building = (function(_super) {
    __extends(Building, _super);

    Building.prototype.angle = 0;

    Building.prototype.radius = 0;

    Building.prototype.r = 0;

    Building.prototype.g = 0;

    Building.prototype.b = 0;

    function Building(h, color) {
      var materials, opacity;
      this.color = color;
      this.needUpdateRequest = __bind(this.needUpdateRequest, this);
      opacity = .1;
      this.color = 0xFFFFFF;
      this.geometry = new THREE.CubeGeometry(5, 1, 5);
      this.material = new THREE.MeshLambertMaterial({
        color: this.color,
        opacity: opacity,
        transparent: true
      });
      materials = [
        this.material, new THREE.MeshBasicMaterial({
          color: 0x222222,
          opacity: 0.1,
          wireframe: false,
          transparent: false
        })
      ];
      THREE.SceneUtils.createMultiMaterialObject.call(this, this.geometry, this.material);
      THREE.Mesh.call(this, this.geometry, this.material);
      this.position.y = 1 / 2;
      return;
    }

    Building.prototype.updatePosition = function(radius, angle) {
      if (radius) {
        this.radius = radius;
      }
      if (angle) {
        this.angle = angle;
      }
      this.position.x = Math.cos(this.angle) * this.radius;
      this.position.z = Math.sin(this.angle) * this.radius;
    };

    Building.prototype.update = function(height, color) {
      this.color = color;
      height /= 4;
      TweenLite.to(this, .5, {
        r: (this.color >> 16 & 255) / 255,
        g: (this.color >> 8 & 255) / 255,
        b: (this.color & 255) / 255
      });
      TweenLite.to(this.geometry.vertices[0], 1, {
        y: height,
        onUpdate: this.needUpdateRequest
      });
      TweenLite.to(this.geometry.vertices[1], 1, {
        y: height
      });
      TweenLite.to(this.geometry.vertices[4], 1, {
        y: height
      });
      TweenLite.to(this.geometry.vertices[5], 1, {
        y: height
      });
    };

    Building.prototype.needUpdateRequest = function() {
      this.material.color.setRGB(this.r, this.g, this.b);
      this.material.opacity = Math.min(Math.max(this.geometry.vertices[0].y / 140, .1), .8);
      this.geometry.verticesNeedUpdate = true;
      this.geometry.elementsNeedUpdate = true;
      this.geometry.morphTargetsNeedUpdate = true;
      this.geometry.uvsNeedUpdate = true;
      this.geometry.normalsNeedUpdate = true;
      this.geometry.colorsNeedUpdate = true;
      this.geometry.tangentsNeedUpdate = true;
    };

    return Building;

  })(THREE.Mesh);

  AScene = (function() {
    AScene.prototype.stage = null;

    AScene.prototype.callback = null;

    function AScene(stage) {
      this.stage = stage;
      return;
    }

    AScene.prototype.transitionIn = function(callback) {
      this.callback = callback;
      this.callback();
    };

    AScene.prototype.transitionOut = function(callback) {
      this.callback = callback;
      this.callback();
    };

    AScene.prototype.onResize = function(width, height) {};

    AScene.prototype.onEnter = function() {};

    AScene.prototype.onExit = function() {};

    AScene.prototype.update = function(dt) {};

    AScene.prototype.dispose = function() {
      this.stage = null;
      this.callback = null;
    };

    return AScene;

  })();

  GameScene = (function(_super) {
    __extends(GameScene, _super);

    function GameScene(stage) {
      GameScene.__super__.constructor.call(this, stage);
      return;
    }

    GameScene.prototype.onEnter = function() {
      var filter, gui, imageData, snd;
      imageData = CanvasUtils.dataFromImage(DataManager.instance.get("./data/spritesheet.png"));
      console.log("Web Audio API Enable: " + SndFX.instance.webAudio);
      snd = new Snd("./sfx/loop.mp3", {
        volume: 1
      });
      snd.play(0, true);
      filter = SndFX.instance.context.createBiquadFilter();
      filter.type = 0;
      filter.frequency.value = 440;
      snd.connectTo(filter, true);
      console.log(filter.frequency);
      gui = new dat.GUI();
      gui.add(filter, "type", ['highpass', 'lowpass', 'bandpass', 'lowshelf', 'highshelf', 'peaking', 'notch', 'allpass']).name("filter.type");
      gui.add(filter.frequency, "value").min(0).max(1000).name("filter.frequency");
      gui.add(filter.Q, "value").min(0.0001).max(10).name("filter.quality");
      gui.add(snd.gainNode.gain, "value").min(0).max(1).name("volume");
      this.stage.mousemove = function(e) {
        var x, y;
        x = (e.global.x / window.innerWidth - .5) * 10;
        y = (e.global.y / window.innerHeight - .5) * 10;
        return snd.panner.setPosition(x, 0, 0);
      };
      Game.stage = this.stage;
    };

    return GameScene;

  })(AScene);

  LoadScene = (function(_super) {
    __extends(LoadScene, _super);

    function LoadScene(stage) {
      this.onSoundLoaded = __bind(this.onSoundLoaded, this);
      this.loadSound = __bind(this.loadSound, this);
      this.loadPixiAsset = __bind(this.loadPixiAsset, this);
      this.loadData = __bind(this.loadData, this);
      LoadScene.__super__.constructor.call(this, stage);
      return;
    }

    LoadScene.prototype.onEnter = function() {
      this.loadData();
    };

    LoadScene.prototype.loadData = function() {
      var urlList;
      urlList = ["./data/spritesheet.png"];
      DataManager.instance.load(urlList, this.loadSound);
    };

    LoadScene.prototype.loadPixiAsset = function() {
      var loader, urlList;
      urlList = ["./fonts/Font name-sd.fnt"];
      loader = new PIXI.AssetLoader(urlList);
      loader.onComplete = this.loadSound;
      loader.load();
    };

    LoadScene.prototype.loadSound = function() {
      var urlList;
      urlList = ["./sfx/intro.mp3", "./sfx/loop.mp3"];
      SndFX.instance.load(urlList, this.onSoundLoaded);
    };

    LoadScene.prototype.onSoundLoaded = function() {
      SceneTraveler.getInstance().travelTo(new GameScene(this.stage));
    };

    return LoadScene;

  })(AScene);

  SceneTraveler = (function() {
    var instance;

    function SceneTraveler() {
      this.onTransitionInComplete = __bind(this.onTransitionInComplete, this);
      this.onTransitionOutComplete = __bind(this.onTransitionOutComplete, this);
      this.travelTo = __bind(this.travelTo, this);
    }

    SceneTraveler.prototype.currentScene = null;

    SceneTraveler.prototype.nextScene = null;

    SceneTraveler.prototype.transitioning = false;

    instance = null;

    SceneTraveler.getInstance = function() {
      if (instance == null) {
        instance = new SceneTraveler();
      }
      return instance;
    };

    SceneTraveler.prototype.travelTo = function(scene) {
      this.nextScene = scene;
      if (this.currentScene !== null) {
        this.currentScene.transitionOut(this.onTransitionOutComplete);
      } else {
        this.onTransitionOutComplete();
      }
    };

    SceneTraveler.prototype.onTransitionOutComplete = function() {
      if (this.currentScene !== null) {
        this.currentScene.onExit();
        this.currentScene.dispose();
      }
      this.currentScene = this.nextScene;
      this.currentScene.onEnter();
      this.currentScene.transitionIn(this.onTransitionInComplete);
      this.nextScene = null;
    };

    SceneTraveler.prototype.onTransitionInComplete = function() {};

    return SceneTraveler;

  })();

  StartScene = (function(_super) {
    __extends(StartScene, _super);

    function StartScene(stage) {
      StartScene.__super__.constructor.call(this, stage);
      return;
    }

    StartScene.prototype.onEnter = function() {};

    StartScene.prototype.onEnd = function() {};

    return StartScene;

  })(AScene);

  /*
  # Usage :
  # SndFX.load(urls,onComplete)
  # SndFX.addFilter(id, filter)
  # SndFX.getFilter(id)
  #
  # snd.onComplete = onSndEnd
  # snd = new Snd(id)
  # snd.play()
  # snd.stop()
  # snd.connectTo(filter)
  # 
  # source => panner => gain => filters => masterGain
  */


  Snd = (function() {
    Snd.prototype.id = null;

    Snd.prototype.source = null;

    Snd.prototype.gain = null;

    Snd.prototype.destination = null;

    Snd.prototype.panner = null;

    Snd.prototype.domAudio = null;

    Snd.prototype._volume = 0;

    Snd.prototype.onComplete = null;

    function Snd(id, options) {
      if (options == null) {
        options = {};
      }
      this.id = id = SndFX.instance.replaceSuffix(id);
      options.autoplay = options.autoplay || false;
      if (SndFX.instance.webAudio) {
        if (options.volume === void 0) {
          options.volume = 1.0;
        }
      } else {
        if (options.volume === void 0) {
          options.volume = SndFX.instance.volume;
        }
      }
      console.log(options.volume);
      options.destination = options.destination || SndFX.instance.masterGain;
      if (SndFX.instance.webAudio) {
        this.source = SndFX.instance.context.createBufferSource();
        this.source.buffer = SndFX.instance.buffers[id];
        this.gainNode = SndFX.instance.createGain();
        this.gainNode.connect(options.destination);
        this.panner = SndFX.instance.createPanner();
        this.panner.setPosition(0, 0, 0);
        this.panner.connect(this.gainNode);
        this.source.connect(this.panner);
        if (options.autoplay) {
          this.play(0);
        }
      } else {
        this.domAudio = new Audio();
        this.domAudio.autoplay = options.autoplay;
        this.domAudio.src = id;
        this.domAudio.load();
      }
      this.volume(options.volume);
      return this;
    }

    Snd.prototype.play = function(_when, _loop) {
      if (_when == null) {
        _when = 0;
      }
      if (_loop == null) {
        _loop = false;
      }
      if (SndFX.instance.webAudio) {
        this.source.loop = _loop;
        if (!this.source.start) {
          this.source.noteOn(_when);
        } else {
          this.source.start(_when);
        }
      } else {
        this.domAudio.loop = _loop;
        this.domAudio.play();
      }
      return this;
    };

    Snd.prototype.stop = function(delay) {
      if (delay == null) {
        delay = 0;
      }
      if (SndFX.instance.webAudio) {
        if (!this.source.stop) {
          this.source.noteOff(delay);
        } else {
          this.source.stop(delay);
        }
      } else {
        this.domAudio.pause();
      }
      return this;
    };

    Snd.prototype.setPosition = function(x, y, z) {
      if (y == null) {
        y = 0;
      }
      if (z == null) {
        z = 0;
      }
      this.panner.setPosition(x, y, z);
    };

    Snd.prototype.volume = function(vol) {
      var _volume;
      if (vol == null) {
        vol = null;
      }
      if (vol >= 0 && vol <= 1) {
        vol = parseFloat(vol);
        if (SndFX.instance.webAudio) {
          this.gainNode.gain.value = vol;
        } else {
          this.domAudio.volume = vol;
        }
        return _volume = vol;
      } else {
        return _volume;
      }
    };

    Snd.prototype.connectTo = function(destination, autoConnectDestination) {
      if (autoConnectDestination == null) {
        autoConnectDestination = false;
      }
      if (!SndFX.instance.webAudio) {
        return;
      }
      this.gainNode.disconnect(0);
      this.gainNode.connect(destination);
      if (autoConnectDestination) {
        destination.connect(SndFX.instance.masterGain);
      }
      return this;
    };

    Snd.prototype.update = function(dt) {};

    Snd.prototype.dispose = function() {
      var id;
      if (SndFX.instance.webAudio) {
        this.panner.disconnect(0);
        this.gainNode.disconnect(0);
        this.source.disconnect(0);
        this.source.stop(0);
        this.panner = null;
        this.gainNode = null;
        this.source.buffer = null;
        this.source = null;
      } else {
        this.domAudio.pause();
        this.domAudio = null;
      }
      SndFX.remove(this);
      id = null;
    };

    return Snd;

  })();

  SndFX = (function() {
    SndFX.prototype.cache = {};

    SndFX.prototype.context = null;

    SndFX.prototype.masterGain = null;

    SndFX.prototype._volume = 1;

    SndFX.prototype.buffers = null;

    SndFX.prototype.snds = null;

    SndFX.prototype.codecs = null;

    SndFX.prototype.onload = null;

    SndFX.prototype.urls = null;

    SndFX.prototype.loadCount = 0;

    SndFX.prototype.webAudio = false;

    function SndFX() {
      var audioTest;
      console.log("SndFX");
      if (SndFX.instance) {
        throw new Error("You can't create an instance of SndFX");
      }
      if (window.AudioContext) {
        this.webAudio = true;
        this.context = new AudioContext();
      } else if (window.webkitAudioContext) {
        this.webAudio = true;
        this.context = new webkitAudioContext();
      } else {
        this.webAudio = false;
      }
      if (this.webAudio) {
        this.masterGain = this.createGain();
        this.masterGain.gain.value = 1;
        this.masterGain.connect(this.context.destination);
      }
      audioTest = new Audio();
      this.codecs = {
        mp3: !!audioTest.canPlayType('audio/mpeg;').replace(/^no$/, ''),
        opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ''),
        ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
        wav: !!audioTest.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ''),
        m4a: !!(audioTest.canPlayType('audio/x-m4a;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
        webm: !!audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, '')
      };
      this.cache = {};
      this.buffers = {};
      this.snds = [];
      return;
    }

    SndFX.prototype.volume = function(vol) {
      var snd, _i, _len, _ref;
      vol = parseFloat(vol);
      if (vol && vol >= 0 && vol <= 1) {
        this._volume = vol;
        if (this.webAudio) {
          this.masterGain.gain.value = vol;
        } else {
          _ref = this.sounds;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            snd = _ref[_i];
            snd.volume(vol);
          }
        }
      }
      if (this.webAudio) {
        return this.masterGain.gain.value;
      } else {
        return this._volume;
      }
    };

    SndFX.prototype.load = function(urls, callback) {
      var i, loader, _i, _j, _k, _ref, _ref1, _ref2;
      this.urls = urls;
      if (callback == null) {
        callback = null;
      }
      for (i = _i = 0, _ref = urls.length; _i < _ref; i = _i += 1) {
        urls[i] = this.replaceSuffix(urls[i]);
      }
      this.onload = callback;
      this.loadCount = 0;
      loader = this;
      if (this.webAudio) {
        for (i = _j = 0, _ref1 = urls.length; _j < _ref1; i = _j += 1) {
          this.loadBuffer(urls[i], i);
        }
      } else {
        for (i = _k = 0, _ref2 = urls.length; _k < _ref2; i = _k += 1) {
          this.loadAudio(urls[i]);
        }
      }
    };

    SndFX.prototype.replaceSuffix = function(url) {
      var suffix;
      if (this.codecs.mp3) {
        return url;
      }
      suffix = "";
      if (this.codecs.ogg) {
        suffix = "ogg";
      } else if (this.codecs.wav) {
        suffix = "wav";
      } else {
        return url;
      }
      url = url.replace("mp3", suffix);
      return url;
    };

    SndFX.prototype.loadBuffer = function(url, index) {
      var loader, request;
      console.log(url);
      request = new XMLHttpRequest();
      request.open("GET", url, true);
      request.responseType = "arraybuffer";
      loader = this;
      request.onload = function() {
        var _this = this;
        return loader.context.decodeAudioData(request.response, function(buffer) {
          if (!buffer) {
            alert('error decoding file data: ' + url);
            return;
          }
          loader.buffers[loader.replaceSuffix(url)] = buffer;
          if (++loader.loadCount === loader.urls.length && loader.onload !== null) {
            return loader.onload();
          }
        }, function(error) {
          return console.error('decodeAudioData error', error);
        });
      };
      request.onerror = function() {
        return alert('BufferLoader: XHR error');
      };
      request.send();
    };

    SndFX.prototype.loadAudio = function(url) {
      var loader, sound;
      loader = this;
      sound = new Audio();
      this.cache[url] = sound;
      sound.addEventListener("canplaythrough", function() {
        if (++loader.loadCount === loader.urls.length && loader.onload !== null) {
          return loader.onload();
        }
      }, false);
      sound.src = url;
      sound.load();
    };

    SndFX.prototype.getByID = function(id) {
      var snd, _i, _len, _ref;
      _ref = this.sounds;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        snd = _ref[_i];
        if (snd.id === id) {
          return snd;
        }
      }
      return null;
    };

    SndFX.prototype.createGain = function() {
      if (this.context.createGain) {
        return this.context.createGain();
      } else {
        return this.context.createGainNode();
      }
    };

    SndFX.prototype.createPanner = function() {
      if (this.context.createPanner) {
        return this.context.createPanner();
      } else {
        return this.context.createPannerNode();
      }
    };

    SndFX.prototype.remove = function(snd) {
      var idx;
      idx = this.sounds.indexOf(snd);
      if (idx === -1) {
        return;
      }
      return this.sounds.splice(idx, 1);
    };

    SndFX.prototype.update = function(dt) {
      var snd, _i, _len, _ref, _results;
      _ref = this.sounds;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        snd = _ref[_i];
        _results.push(snd.update(dt));
      }
      return _results;
    };

    SndFX.instance = new SndFX();

    return SndFX;

  })();

  CanvasUtils = (function() {
    function CanvasUtils() {}

    CanvasUtils.fromImage = function(image) {
      var canvas, context;
      canvas = document.createElement('canvas');
      canvas.width = image.width;
      canvas.height = image.height;
      context = canvas.getContext('2d');
      context.width = image.width;
      context.height = image.height;
      context.drawImage(image, 0, 0);
      console.log(canvas);
      return canvas;
    };

    CanvasUtils.dataFromImage = function(image) {
      return CanvasUtils.fromImage(image).getContext('2d').getImageData(0, 0, image.width, image.height);
    };

    return CanvasUtils;

  })();

  M_PI = Math.PI;

  M_2PI = Math.PI * 2;

  M_PI2 = Math.PI / 2;

  M_PI4 = Math.PI / 4;

  M_PI8 = Math.PI / 8;

  HitTest = (function() {
    function HitTest() {
      return;
    }

    HitTest.testCircle = function(position, object, radius) {
      var dist, dx, dy;
      if (radius == null) {
        radius = object.radius;
      }
      dx = object.position.x - position.x;
      dy = object.position.y - position.y;
      dist = Math.sqrt(dx * dx + dy * dy);
      return dist <= radius;
    };

    HitTest.testElipse = function(position, object, width, height) {
      var dx, dy;
      dx = object.position.x - position.x;
      dy = object.position.y - position.y;
      return ((dx * dx) / (width * width)) + ((dy * dy) / (height * height)) <= 1.0;
    };

    HitTest.testRect = function(position, object) {
      return position.x >= object.position.x && position.y >= object.position.y && position.x <= object.position.x + object.width && position.y <= object.position.y + object.height;
    };

    HitTest.testRect = function(position, object, centred) {
      position.x += object.width / 2;
      position.y += object.height / 2;
      return HitTest.testRect(position, object);
    };

    return HitTest;

  })();

  TAN_HALF_PI = Math.tan(Math.PI / 2);

  vector = function(x, y) {
    return {
      x: x,
      y: y
    };
  };

  delta = function(a, b) {
    return vector(a.x - b.x, a.y - b.y);
  };

  angle = function(d) {
    return Math.atan((1.0 * d.y) / d.x);
  };

  angle_between = function(a, b) {
    return Math.acos((a.x * b.x + a.y * b.y) / (len(a) * len(b)));
  };

  len = function(v) {
    return Math.sqrt(v.x * v.x + v.y * v.y);
  };

  add = function(a, b) {
    return vector(a.x + b.x, a.y + b.y);
  };

  average = function(l) {
    var i, x, y;
    x = 0;
    y = 0;
    i = 0;
    while (i < l.length) {
      x += l[i].x;
      y += l[i].y;
      i++;
    }
    return vector(x / l.length, y / l.length);
  };

  findCorner = function(line) {
    var ac, c, c2, corners, d, i, lastCorner, pt, _i, _j, _ref, _ref1;
    corners = [line[0]];
    lastCorner = line[0];
    for (i = _i = 1, _ref = line.length - 1; _i < _ref; i = _i += 1) {
      pt = line[i];
      d = delta(lastCorner, pt);
      if (Math.abs(len(d)) > 10) {
        ac = delta(pt, line[i + 1]);
        if (Math.abs(angle_between(ac, d)) > Math.PI / 4) {
          pt.index = i;
          corners.push(pt);
          lastCorner = pt;
        }
      }
    }
    corners.push(line[line.length - 1]);
    for (i = _j = 1, _ref1 = corners.length; _j <= _ref1; i = _j += 1) {
      c = corners[i % corners.length];
      c2 = corners[i - 1];
      if ((Math.abs(c.x - c2.x) + Math.abs(c.y - c2.y)) < 30) {
        corners.splice(i - 1, 1);
        break;
      }
    }
    return corners;
  };

  isTriangle = function(corners) {
    var c0, c1, c2;
    if (corners.length !== 3) {
      return false;
    }
    corners.sort(function(a, b) {
      return a.x < b.x;
    });
    c0 = corners[0];
    c1 = corners[1];
    c2 = corners[2];
    if (c0.y > c1.y && c2.y > c1.y) {
      return true;
    }
    return false;
  };

  isSquare = function(corners) {
    var c0, c1, c2, c3, tolerance;
    if (corners.length !== 4) {
      return false;
    }
    corners.sort(function(a, b) {
      return a.x < b.x;
    });
    if (corners[0].y < corners[1].y) {
      c0 = corners[0];
      corners[0] = corners[1];
      corners[1] = c0;
    }
    if (corners[2].y < corners[3].y) {
      c2 = corners[2];
      corners[2] = corners[3];
      corners[3] = c2;
    }
    c0 = corners[0];
    c1 = corners[1];
    c2 = corners[2];
    c3 = corners[3];
    tolerance = 25;
    if (Math.abs(c0.x - c1.x) < tolerance && Math.abs(c2.x - c3.x) < tolerance) {
      return true;
    }
    return false;
  };

  NumberUtils = (function() {
    function NumberUtils() {
      throw new Error("you can t create an instance of NumberUtils");
    }

    NumberUtils.addZero = function(string, minLenght) {
      string += "";
      while (string.length < minLenght) {
        string = "0" + string;
      }
      return string;
    };

    return NumberUtils;

  })();

  ObjectPool = (function() {
    function ObjectPool(create, minSize, maxSize) {
      var _i, _ref;
      this.create = create;
      this.minSize = minSize;
      this.maxSize = maxSize;
      this.list = [];
      for (_i = 0, _ref = this.minSize; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--) {
        this.add();
      }
      return;
    }

    ObjectPool.prototype.add = function() {
      return this.list.push(this.create());
    };

    ObjectPool.prototype.checkOut = function() {
      var i;
      if (this.list.length === 0) {
        return i = this.create();
      } else {
        return i = this.list.pop();
      }
    };

    ObjectPool.prototype.checkIn = function(item) {
      if (this.list.length < this.maxSize) {
        return this.list.push(item);
      }
    };

    return ObjectPool;

  })();

  BackgroundController = (function() {
    function BackgroundController() {
      return;
    }

    return BackgroundController;

  })();

  Cloud = (function(_super) {
    __extends(Cloud, _super);

    Cloud.prototype.angle = 0;

    Cloud.prototype.radius = 0;

    Cloud.prototype.r = 0;

    Cloud.prototype.g = 0;

    Cloud.prototype.b = 0;

    function Cloud() {
      this.geometry = new THREE.CubeGeometry(10 + Math.random() * 20, 10, 10 + Math.random() * 20);
      this.material = new THREE.MeshBasicMaterial({
        color: 0xFFFFFF,
        opacity: .9,
        transparent: true
      });
      THREE.Mesh.call(this, this.geometry, this.material);
      this.position.y = 100 + Math.random() * 100;
      this.position.x = Math.random() * 300 - 150;
      this.position.z = Math.random() * 300 - 150;
      return;
    }

    return Cloud;

  })(THREE.Mesh);

}).call(this);
